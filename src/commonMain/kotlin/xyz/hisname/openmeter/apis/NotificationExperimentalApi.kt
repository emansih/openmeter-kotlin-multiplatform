/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package xyz.hisname.openmeter.apis

import xyz.hisname.openmeter.models.ConflictProblem
import xyz.hisname.openmeter.models.NotificationChannel
import xyz.hisname.openmeter.models.NotificationChannelCreateRequest
import xyz.hisname.openmeter.models.NotificationChannelsResponse
import xyz.hisname.openmeter.models.NotificationEventsResponse
import xyz.hisname.openmeter.models.NotificationRule
import xyz.hisname.openmeter.models.NotificationRuleCreateRequest
import xyz.hisname.openmeter.models.NotificationRulesResponse
import xyz.hisname.openmeter.models.Problem
import xyz.hisname.openmeter.models.TestNotificationRule201Response

import xyz.hisname.openmeter.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class NotificationExperimentalApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Create a notification channel
     * Create a new notification channel. 
     * @param notificationChannelCreateRequest The notification channel to create.
     * @return NotificationChannel
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createNotificationChannel(notificationChannelCreateRequest: NotificationChannelCreateRequest): HttpResponse<NotificationChannel> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = notificationChannelCreateRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/notification/channels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a notification rule
     * Create a new notification rule. 
     * @param notificationRuleCreateRequest The notification rule to create.
     * @return NotificationRule
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createNotificationRule(notificationRuleCreateRequest: NotificationRuleCreateRequest): HttpResponse<NotificationRule> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = notificationRuleCreateRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/notification/rules",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete a notification channel
     * Delete notification channel by id. 
     * @param channelId A unique ULID identifier for a notification channel.
     * @return void
     */
    open suspend fun deleteNotificationChannel(channelId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/notification/channels/{channelId}".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a notification rule
     * Delete notification rule by id. 
     * @param ruleId A unique ULID identifier for a notification rule.
     * @return void
     */
    open suspend fun deleteNotificationRule(ruleId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/notification/rules/{ruleId}".replace("{" + "ruleId" + "}", "$ruleId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get notification channel
     * Get a notification channel by id. 
     * @param channelId A unique ULID identifier for a notification channel.
     * @return NotificationChannel
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNotificationChannel(channelId: kotlin.String): HttpResponse<NotificationChannel> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/notification/channels/{channelId}".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get notification event
     * Get a notification event by id. 
     * @param eventId A unique ULID identifier for a notification event.
     * @return TestNotificationRule201Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNotificationEvent(eventId: kotlin.String): HttpResponse<TestNotificationRule201Response> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/notification/events/{eventId}".replace("{" + "eventId" + "}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get notification rule
     * Get a notification rule by id. 
     * @param ruleId A unique ULID identifier for a notification rule.
     * @return NotificationRule
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNotificationRule(ruleId: kotlin.String): HttpResponse<NotificationRule> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/notification/rules/{ruleId}".replace("{" + "ruleId" + "}", "$ruleId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListNotificationChannels(val value: kotlin.String) {
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "type")
        type("type"),
        
        @SerialName(value = "createdAt")
        createdAt("createdAt"),
        
        @SerialName(value = "updatedAt")
        updatedAt("updatedAt")
        
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderListNotificationChannels(val value: kotlin.String) {
        
        @SerialName(value = "ASC")
        SortOrderASC("ASC"),
        
        @SerialName(value = "DESC")
        SortOrderDESC("DESC")
        
    }

    /**
     * List notification channels
     * List all notification channels. 
     * @param page Page number to return (optional, default to 1)
     * @param pageSize Number of entries to return per page (optional, default to 100)
     * @param orderBy Order by field (optional, default to id)
     * @param order Order by field.  Usage: &#x60;?order&#x3D;ASC&#x60;  (optional, default to ASC)
     * @param includeDisabled Include disabled entries. (optional, default to false)
     * @param includeDeleted Include deleted entries. (optional, default to false)
     * @return NotificationChannelsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listNotificationChannels(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 100, orderBy: OrderByListNotificationChannels? = OrderByListNotificationChannels.id, order: OrderListNotificationChannels? = OrderListNotificationChannels.SortOrderASC, includeDisabled: kotlin.Boolean? = false, includeDeleted: kotlin.Boolean? = false): HttpResponse<NotificationChannelsResponse> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        order?.apply { localVariableQuery["order"] = listOf("${ order.value }") }
        includeDisabled?.apply { localVariableQuery["includeDisabled"] = listOf("$includeDisabled") }
        includeDeleted?.apply { localVariableQuery["includeDeleted"] = listOf("$includeDeleted") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/notification/channels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListNotificationEvents(val value: kotlin.String) {
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "createdAt")
        createdAt("createdAt")
        
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderListNotificationEvents(val value: kotlin.String) {
        
        @SerialName(value = "ASC")
        SortOrderASC("ASC"),
        
        @SerialName(value = "DESC")
        SortOrderDESC("DESC")
        
    }

    /**
     * List notification evens
     * List all notification events. 
     * @param page Page number to return (optional, default to 1)
     * @param pageSize Number of entries to return per page (optional, default to 100)
     * @param orderBy Order by field (optional, default to createdAt)
     * @param order Order by field.  Usage: &#x60;?order&#x3D;ASC&#x60;  (optional, default to ASC)
     * @param from Start date-time in RFC 3339 format. Inclusive.  (optional)
     * @param to End date-time in RFC 3339 format. Inclusive.  (optional)
     * @param feature Filtering by multiple features.  Usage: &#x60;?feature&#x3D;feature-1&amp;feature&#x3D;feature-2&#x60;  (optional)
     * @param subject Filtering by multiple subjects.  Usage: &#x60;?subject&#x3D;customer-1&amp;subject&#x3D;customer-2&#x60;  (optional)
     * @param rule Filtering by multiple rules.  Usage: &#x60;?rule&#x3D;ID1&amp;rule&#x3D;rule&#x3D;ID2&#x60;  (optional)
     * @param channel Filtering by multiple channels.  Usage: &#x60;?channel&#x3D;ID1&amp;channel&#x3D;ID2&#x60;  (optional)
     * @return NotificationEventsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listNotificationEvents(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 100, orderBy: OrderByListNotificationEvents? = OrderByListNotificationEvents.createdAt, order: OrderListNotificationEvents? = OrderListNotificationEvents.SortOrderASC, from: kotlinx.datetime.Instant? = null, to: kotlinx.datetime.Instant? = null, feature: kotlin.collections.List<kotlin.String>? = null, subject: kotlin.collections.List<kotlin.String>? = null, rule: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.collections.List<kotlin.String>? = null): HttpResponse<NotificationEventsResponse> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        order?.apply { localVariableQuery["order"] = listOf("${ order.value }") }
        from?.apply { localVariableQuery["from"] = listOf("$from") }
        to?.apply { localVariableQuery["to"] = listOf("$to") }
        feature?.apply { localVariableQuery["feature"] = toMultiValue(this, "multi") }
        subject?.apply { localVariableQuery["subject"] = toMultiValue(this, "multi") }
        rule?.apply { localVariableQuery["rule"] = toMultiValue(this, "multi") }
        channel?.apply { localVariableQuery["channel"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/notification/events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListNotificationRules(val value: kotlin.String) {
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "type")
        type("type"),
        
        @SerialName(value = "createdAt")
        createdAt("createdAt"),
        
        @SerialName(value = "updatedAt")
        updatedAt("updatedAt")
        
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderListNotificationRules(val value: kotlin.String) {
        
        @SerialName(value = "ASC")
        SortOrderASC("ASC"),
        
        @SerialName(value = "DESC")
        SortOrderDESC("DESC")
        
    }

    /**
     * List notification rules
     * List all notification rules. 
     * @param page Page number to return (optional, default to 1)
     * @param pageSize Number of entries to return per page (optional, default to 100)
     * @param orderBy Order by field (optional, default to id)
     * @param order Order by field.  Usage: &#x60;?order&#x3D;ASC&#x60;  (optional, default to ASC)
     * @param includeDisabled Include disabled entries. (optional, default to false)
     * @param includeDeleted Include deleted entries. (optional, default to false)
     * @param feature Filtering by multiple features.  Usage: &#x60;?feature&#x3D;feature-1&amp;feature&#x3D;feature-2&#x60;  (optional)
     * @param channel Filtering by multiple notification channels.  Usage: &#x60;?channel&#x3D;channel-1&amp;channel&#x3D;channel-2&#x60;  (optional)
     * @return NotificationRulesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listNotificationRules(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 100, orderBy: OrderByListNotificationRules? = OrderByListNotificationRules.id, order: OrderListNotificationRules? = OrderListNotificationRules.SortOrderASC, includeDisabled: kotlin.Boolean? = false, includeDeleted: kotlin.Boolean? = false, feature: kotlin.collections.List<kotlin.String>? = null, channel: kotlin.collections.List<kotlin.String>? = null): HttpResponse<NotificationRulesResponse> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        order?.apply { localVariableQuery["order"] = listOf("${ order.value }") }
        includeDisabled?.apply { localVariableQuery["includeDisabled"] = listOf("$includeDisabled") }
        includeDeleted?.apply { localVariableQuery["includeDeleted"] = listOf("$includeDeleted") }
        feature?.apply { localVariableQuery["feature"] = toMultiValue(this, "multi") }
        channel?.apply { localVariableQuery["channel"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/notification/rules",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Test notification rule
     * Test a notification rule by sending a test event with random data. 
     * @param ruleId A unique ULID identifier for a notification rule.
     * @return TestNotificationRule201Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun testNotificationRule(ruleId: kotlin.String): HttpResponse<TestNotificationRule201Response> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/notification/rules/{ruleId}/test".replace("{" + "ruleId" + "}", "$ruleId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update notification channel
     * Update a notification channel by id. 
     * @param channelId A unique ULID identifier for a notification channel.
     * @param notificationChannelCreateRequest The notification channel to update.
     * @return NotificationChannel
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateNotificationChannel(channelId: kotlin.String, notificationChannelCreateRequest: NotificationChannelCreateRequest): HttpResponse<NotificationChannel> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = notificationChannelCreateRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/api/v1/notification/channels/{channelId}".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update a notification rule
     * Update a notification rule by id. 
     * @param ruleId A unique ULID identifier for a notification rule.
     * @param notificationRuleCreateRequest The notification rule to update.
     * @return NotificationRule
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateNotificationRule(ruleId: kotlin.String, notificationRuleCreateRequest: NotificationRuleCreateRequest): HttpResponse<NotificationRule> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = notificationRuleCreateRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/api/v1/notification/rules/{ruleId}".replace("{" + "ruleId" + "}", "$ruleId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
