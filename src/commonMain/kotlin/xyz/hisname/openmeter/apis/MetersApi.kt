/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package xyz.hisname.openmeter.apis

import xyz.hisname.openmeter.models.Meter
import xyz.hisname.openmeter.models.MeterQueryResult
import xyz.hisname.openmeter.models.Problem
import xyz.hisname.openmeter.models.WindowSize

import xyz.hisname.openmeter.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class MetersApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * ☁ Create meter
     * *Available in OpenMeter Cloud.* *In the open-source version, meters are created in the configuration file.*  Create a meter. 
     * @param meter The meter to create.
     * @return Meter
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createMeter(meter: Meter): HttpResponse<Meter> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = meter

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/meters",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * ☁ Delete meter
     * *Available in OpenMeter Cloud.*  Delete a meter by ID or slug. 
     * @param meterIdOrSlug A unique identifier for the meter.
     * @return void
     */
    open suspend fun deleteMeter(meterIdOrSlug: String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/meters/{meterIdOrSlug}".replace("{" + "meterIdOrSlug" + "}", meterIdOrSlug),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get meter
     * Get meter by ID or slug
     * @param meterIdOrSlug A unique identifier for the meter.
     * @return Meter
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMeter(meterIdOrSlug: String): HttpResponse<Meter> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/meters/{meterIdOrSlug}".replace("{" + "meterIdOrSlug" + "}", meterIdOrSlug),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List meter subjects
     * List subjects for a meter.
     * @param meterIdOrSlug A unique identifier for the meter.
     * @return kotlin.collections.List<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listMeterSubjects(meterIdOrSlug: String): HttpResponse<kotlin.collections.List<kotlin.String>> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/meters/{meterIdOrSlug}/subjects".replace("{" + "meterIdOrSlug" + "}", meterIdOrSlug),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListMeterSubjectsResponse>().map { value }
    }

    @Serializable(ListMeterSubjectsResponse.Companion::class)
    private class ListMeterSubjectsResponse(val value: List<kotlin.String>) {
        companion object : KSerializer<ListMeterSubjectsResponse> {
            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListMeterSubjectsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListMeterSubjectsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * List meters
     * List meters.
     * @return kotlin.collections.List<Meter>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listMeters(): HttpResponse<kotlin.collections.List<Meter>> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/meters",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListMetersResponse>().map { value }
    }

    @Serializable(ListMetersResponse.Companion::class)
    private class ListMetersResponse(val value: List<Meter>) {
        companion object : KSerializer<ListMetersResponse> {
            private val serializer: KSerializer<List<Meter>> = serializer<List<Meter>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListMetersResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListMetersResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Query meter
     * Query meter for usage.
     * @param meterIdOrSlug A unique identifier for the meter.
     * @param from Start date-time in RFC 3339 format. Inclusive.  (optional)
     * @param to End date-time in RFC 3339 format. Inclusive.  (optional)
     * @param windowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.  (optional)
     * @param windowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones). If not specified, the UTC timezone will be used.  (optional, default to "UTC")
     * @param subject Filtering by multiple subjects.  Usage: &#x60;?subject&#x3D;customer-1&amp;subject&#x3D;customer-2&#x60;  (optional)
     * @param filterGroupBy  (optional)
     * @param groupBy If not specified a single aggregate will be returned for each subject and time window. &#x60;subject&#x60; is a reserved group by value.  (optional)
     * @return MeterQueryResult
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun queryMeter(meterIdOrSlug: String, from: kotlinx.datetime.Instant? = null, to: kotlinx.datetime.Instant? = null, windowSize: WindowSize? = null, windowTimeZone: kotlin.String? = "UTC", subject: kotlin.collections.List<kotlin.String>? = null, filterGroupBy: kotlin.collections.Map<kotlin.String, kotlin.String>? = null, groupBy: kotlin.collections.List<kotlin.String>? = null): HttpResponse<MeterQueryResult> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        from?.apply { localVariableQuery["from"] = listOf("$from") }
        to?.apply { localVariableQuery["to"] = listOf("$to") }
        windowSize?.apply { localVariableQuery["windowSize"] = listOf("$windowSize") }
        windowTimeZone?.apply { localVariableQuery["windowTimeZone"] = listOf("$windowTimeZone") }
        subject?.apply { localVariableQuery["subject"] = toMultiValue(this, "multi") }
        filterGroupBy?.apply {
            localVariableQuery["filterGroupBy"] = toMultiValue(
                this.map { "${it.key}:${it.value}" },
                ""
            )
        }
        groupBy?.apply { localVariableQuery["groupBy"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/meters/{meterIdOrSlug}/query".replace("{" + "meterIdOrSlug" + "}", "$meterIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
