/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package xyz.hisname.openmeter.apis

import xyz.hisname.openmeter.models.Entitlement
import xyz.hisname.openmeter.models.EntitlementCreateInputs
import xyz.hisname.openmeter.models.EntitlementGrant
import xyz.hisname.openmeter.models.EntitlementGrantCreateInput
import xyz.hisname.openmeter.models.EntitlementValue
import xyz.hisname.openmeter.models.Feature
import xyz.hisname.openmeter.models.FeatureCreateInputs
import xyz.hisname.openmeter.models.GetEntitlementById
import xyz.hisname.openmeter.models.ListEntitlementGrantResponse
import xyz.hisname.openmeter.models.ListEntitlementResponse
import xyz.hisname.openmeter.models.ListFeatureResponse
import xyz.hisname.openmeter.models.ResetEntitlementUsageRequest
import xyz.hisname.openmeter.models.WindowedBalanceHistory

import xyz.hisname.openmeter.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import kotlinx.serialization.*
import kotlinx.serialization.encoding.*

open class EntitlementsExperimentalApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Create an entitlement
     * OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).  - Boolean entitlements define static feature access, e.g. \&quot;Can use SSO authentication\&quot;. - Static entitlements let you pass along a configuration while granting access, e.g. \&quot;Using this feature with X Y settings\&quot; (passed in the config). - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.  A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.  Once an entitlement is created you cannot modify it, only delete it. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementCreateInputs The entitlement to create.
     * @return Entitlement
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createEntitlement(subjectIdOrKey: kotlin.String, entitlementCreateInputs: EntitlementCreateInputs): HttpResponse<Entitlement> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = entitlementCreateInputs

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a feature
     * Features are either metered or static. A feature is metered if meterSlug is provided at creation. For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter&#39;s groupBy fields. Only meters with SUM and COUNT aggregation are supported for features.  Features cannot be updated later, only archived. 
     * @param featureCreateInputs The feature to create.
     * @return Feature
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createFeature(featureCreateInputs: FeatureCreateInputs): HttpResponse<Feature> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = featureCreateInputs

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/features",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a grant
     * Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don&#39;t have to periodically create new grants. You can only issue grants for active metered entitlements.  A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.  Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.  Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).  Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset &#x3D; MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))  Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementIdOrFeatureKey The id of the entitlement or the key of the feature.
     * @param entitlementGrantCreateInput The grant to create.
     * @return EntitlementGrant
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createGrant(subjectIdOrKey: kotlin.String, entitlementIdOrFeatureKey: kotlin.String, entitlementGrantCreateInput: EntitlementGrantCreateInput): HttpResponse<EntitlementGrant> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = entitlementGrantCreateInput

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementIdOrFeatureKey" + "}", "$entitlementIdOrFeatureKey"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete an entitlement
     * Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when \&quot;migrating\&quot; features you have to delete the old entitlements as well. As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementId A unique ULID for an entitlement.
     * @return void
     */
    open suspend fun deleteEntitlement(subjectIdOrKey: kotlin.String, entitlementId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementId" + "}", "$entitlementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Archive a feature
     * Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements. This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis. 
     * @param featureId A unique ULID identifier for a feature.
     * @return void
     */
    open suspend fun deleteFeature(featureId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/features/{featureId}".replace("{" + "featureId" + "}", "$featureId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get an entitlement
     * Get entitlement by id. For checking entitlement access, use the /value endpoint instead. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementId A unique ULID for an entitlement.
     * @return GetEntitlementById200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getEntitlement(subjectIdOrKey: kotlin.String, entitlementId: kotlin.String): HttpResponse<GetEntitlementById> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementId" + "}", "$entitlementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get an entitlement
     * Get entitlement by id. 
     * @param entitlementId A unique ULID for an entitlement.
     * @return GetEntitlementById200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getEntitlementById(entitlementId: kotlin.String): HttpResponse<GetEntitlementById> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/entitlements/{entitlementId}".replace("{" + "entitlementId" + "}", "$entitlementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter windowSize
     */
    @Serializable
    enum class WindowSizeGetEntitlementHistory(val value: kotlin.String) {
        
        @SerialName(value = "MINUTE")
        MINUTE("MINUTE"),
        
        @SerialName(value = "HOUR")
        HOUR("HOUR"),
        
        @SerialName(value = "DAY")
        DAY("DAY")
        
    }

    /**
     * Get the balance history of a specific entitlement.
     * Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.  BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.  WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementId A unique ULID for an entitlement.
     * @param windowSize Size of the time window to group the history by. Cannot be shorter than meter granularity. 
     * @param from Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.  (optional)
     * @param to End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now. If not now then gets truncated to the granularity of the underlying meter.  (optional)
     * @param windowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones). If not specified, the UTC timezone will be used.  (optional, default to "UTC")
     * @return WindowedBalanceHistory
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getEntitlementHistory(subjectIdOrKey: kotlin.String, entitlementId: kotlin.String, windowSize: WindowSizeGetEntitlementHistory, from: kotlinx.datetime.Instant? = null, to: kotlinx.datetime.Instant? = null, windowTimeZone: kotlin.String? = "UTC"): HttpResponse<WindowedBalanceHistory> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        from?.apply { localVariableQuery["from"] = listOf("$from") }
        to?.apply { localVariableQuery["to"] = listOf("$to") }
        windowSize?.apply { localVariableQuery["windowSize"] = listOf("${ windowSize.value }") }
        windowTimeZone?.apply { localVariableQuery["windowTimeZone"] = listOf("$windowTimeZone") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementId" + "}", "$entitlementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get the current value and access of an entitlement
     * This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.  For convenience reasons, /value works with both entitlementId and featureKey. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementIdOrFeatureKey The id of the entitlement or the key of the feature.
     * @param time Point of time to check value: date-time in RFC 3339 format. Defaults to now.  (optional)
     * @return EntitlementValue
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getEntitlementValue(subjectIdOrKey: kotlin.String, entitlementIdOrFeatureKey: kotlin.String, time: kotlinx.datetime.Instant? = null): HttpResponse<EntitlementValue> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        time?.apply { localVariableQuery["time"] = listOf("$time") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementIdOrFeatureKey" + "}", "$entitlementIdOrFeatureKey"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get feature
     * Get a feature by id. 
     * @param featureId A unique ULID identifier for a feature.
     * @return Feature
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getFeature(featureId: kotlin.String): HttpResponse<Feature> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/features/{featureId}".replace("{" + "featureId" + "}", "$featureId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListEntitlementGrants(val value: kotlin.String) {
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "createdAt")
        createdAt("createdAt"),
        
        @SerialName(value = "updatedAt")
        updatedAt("updatedAt")
        
    }

    /**
     * List grants for an entitlement
     * List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementIdOrFeatureKey The id of the entitlement or the key of the feature.
     * @param includeDeleted Include deleted entries. (optional, default to false)
     * @param orderBy Order by field (optional, default to updatedAt)
     * @return kotlin.collections.List<EntitlementGrant>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listEntitlementGrants(subjectIdOrKey: kotlin.String, entitlementIdOrFeatureKey: kotlin.String, includeDeleted: kotlin.Boolean? = false, orderBy: OrderByListEntitlementGrants? = OrderByListEntitlementGrants.updatedAt): HttpResponse<kotlin.collections.List<EntitlementGrant>> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeDeleted?.apply { localVariableQuery["includeDeleted"] = listOf("$includeDeleted") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementIdOrFeatureKey" + "}", "$entitlementIdOrFeatureKey"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListEntitlementGrantsResponse>().map { value }
    }

    @Serializable(ListEntitlementGrantsResponse.Companion::class)
    private class ListEntitlementGrantsResponse(val value: List<EntitlementGrant>) {
        companion object : KSerializer<ListEntitlementGrantsResponse> {
            private val serializer: KSerializer<List<EntitlementGrant>> = serializer<List<EntitlementGrant>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListEntitlementGrantsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListEntitlementGrantsResponse(serializer.deserialize(decoder))
        }
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderListEntitlements(val value: kotlin.String) {
        
        @SerialName(value = "ASC")
        SortOrderASC("ASC"),
        
        @SerialName(value = "DESC")
        SortOrderDESC("DESC")
        
    }


    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListEntitlements(val value: kotlin.String) {
        
        @SerialName(value = "createdAt")
        createdAt("createdAt"),
        
        @SerialName(value = "updatedAt")
        updatedAt("updatedAt")
        
    }

    /**
     * List entitlements
     * List all entitlements regardless of subject. This endpoint is intended for administrative purposes. If page is provided that takes precedence and the paginated response is returned. 
     * @param page Page number to return (optional, default to 1)
     * @param pageSize Number of entries to return per page (optional, default to 100)
     * @param limit Number of entries to return (optional, default to 1000)
     * @param offset Number of entries to skip (optional, default to 0)
     * @param subject Filtering by multiple subjects.  Usage: &#x60;?subject&#x3D;customer-1&amp;subject&#x3D;customer-2&#x60;  (optional)
     * @param feature Filtering by multiple features.  Usage: &#x60;?feature&#x3D;feature-1&amp;feature&#x3D;feature-2&#x60;  (optional)
     * @param entitlementType Filtering by multiple entitlement types.  Usage: &#x60;?entitlementType&#x3D;metered&amp;entitlementType&#x3D;static&#x60;  (optional)
     * @param order Order by field.  Usage: &#x60;?order&#x3D;ASC&#x60;  (optional, default to ASC)
     * @param orderBy Order by field (optional, default to createdAt)
     * @return ListEntitlementResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listEntitlements(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 100, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, subject: kotlin.collections.List<kotlin.String>? = null, feature: kotlin.collections.List<kotlin.String>? = null, entitlementType: kotlin.collections.List<kotlin.String>? = null, order: OrderListEntitlements? = OrderListEntitlements.SortOrderASC, orderBy: OrderByListEntitlements? = OrderByListEntitlements.createdAt): HttpResponse<ListEntitlementResponse> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        subject?.apply { localVariableQuery["subject"] = toMultiValue(this, "multi") }
        feature?.apply { localVariableQuery["feature"] = toMultiValue(this, "multi") }
        entitlementType?.apply { localVariableQuery["entitlementType"] = toMultiValue(this, "multi") }
        order?.apply { localVariableQuery["order"] = listOf("${ order.value }") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/entitlements",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderListFeatures(val value: kotlin.String) {
        
        @SerialName(value = "ASC")
        SortOrderASC("ASC"),
        
        @SerialName(value = "DESC")
        SortOrderDESC("DESC")
        
    }


    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListFeatures(val value: kotlin.String) {
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "createdAt")
        createdAt("createdAt"),
        
        @SerialName(value = "updatedAt")
        updatedAt("updatedAt")
        
    }

    /**
     * List features
     * List all features. If page is provided that takes precedence and the paginated response is returned. 
     * @param page Page number to return (optional, default to 1)
     * @param pageSize Number of entries to return per page (optional, default to 100)
     * @param limit Number of entries to return (optional, default to 1000)
     * @param offset Number of entries to skip (optional, default to 0)
     * @param meterSlug Filtering by multiple meterSlug.  Usage: &#x60;?meterSlug&#x3D;meter-1&amp;meterSlug&#x3D;meter-2&#x60;  (optional)
     * @param order Order by field.  Usage: &#x60;?order&#x3D;ASC&#x60;  (optional, default to ASC)
     * @param orderBy Order by field (optional, default to updatedAt)
     * @param includeArchived Include archived features. (optional, default to false)
     * @return ListFeatureResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listFeatures(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 100, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, meterSlug: kotlin.collections.List<kotlin.String>? = null, order: OrderListFeatures? = OrderListFeatures.SortOrderASC, orderBy: OrderByListFeatures? = OrderByListFeatures.updatedAt, includeArchived: kotlin.Boolean? = false): HttpResponse<ListFeatureResponse> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        meterSlug?.apply { localVariableQuery["meterSlug"] = toMultiValue(this, "multi") }
        order?.apply { localVariableQuery["order"] = listOf("${ order.value }") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        includeArchived?.apply { localVariableQuery["includeArchived"] = listOf("$includeArchived") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/features",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderListGrants(val value: kotlin.String) {
        
        @SerialName(value = "ASC")
        SortOrderASC("ASC"),
        
        @SerialName(value = "DESC")
        SortOrderDESC("DESC")
        
    }


    /**
     * enum for parameter orderBy
     */
    @Serializable
    enum class OrderByListGrants(val value: kotlin.String) {
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "createdAt")
        createdAt("createdAt"),
        
        @SerialName(value = "updatedAt")
        updatedAt("updatedAt")
        
    }

    /**
     * List grants
     * List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only. To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.  If page is provided that takes precedence and the paginated response is returned. 
     * @param page Page number to return (optional, default to 1)
     * @param pageSize Number of entries to return per page (optional, default to 100)
     * @param limit Number of entries to return (optional, default to 1000)
     * @param offset Number of entries to skip (optional, default to 0)
     * @param subject Filtering by multiple subjects.  Usage: &#x60;?subject&#x3D;customer-1&amp;subject&#x3D;customer-2&#x60;  (optional)
     * @param feature Filtering by multiple features.  Usage: &#x60;?feature&#x3D;feature-1&amp;feature&#x3D;feature-2&#x60;  (optional)
     * @param order Order by field.  Usage: &#x60;?order&#x3D;ASC&#x60;  (optional, default to ASC)
     * @param orderBy Order by field (optional, default to updatedAt)
     * @param includeDeleted Include deleted entries. (optional, default to false)
     * @return ListEntitlementGrantResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listGrants(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 100, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, subject: kotlin.collections.List<kotlin.String>? = null, feature: kotlin.collections.List<kotlin.String>? = null, order: OrderListGrants? = OrderListGrants.SortOrderASC, orderBy: OrderByListGrants? = OrderByListGrants.updatedAt, includeDeleted: kotlin.Boolean? = false): HttpResponse<ListEntitlementGrantResponse> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["pageSize"] = listOf("$pageSize") }
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        subject?.apply { localVariableQuery["subject"] = toMultiValue(this, "multi") }
        feature?.apply { localVariableQuery["feature"] = toMultiValue(this, "multi") }
        order?.apply { localVariableQuery["order"] = listOf("${ order.value }") }
        orderBy?.apply { localVariableQuery["orderBy"] = listOf("${ orderBy.value }") }
        includeDeleted?.apply { localVariableQuery["includeDeleted"] = listOf("$includeDeleted") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/grants",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List entitlements of a subject
     * List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param includeDeleted Include deleted entries. (optional, default to false)
     * @return kotlin.collections.List<Entitlement>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listSubjectEntitlements(subjectIdOrKey: kotlin.String, includeDeleted: kotlin.Boolean? = false): HttpResponse<kotlin.collections.List<Entitlement>> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeDeleted?.apply { localVariableQuery["includeDeleted"] = listOf("$includeDeleted") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListSubjectEntitlementsResponse>().map { value }
    }

    @Serializable(ListSubjectEntitlementsResponse.Companion::class)
    private class ListSubjectEntitlementsResponse(val value: List<Entitlement>) {
        companion object : KSerializer<ListSubjectEntitlementsResponse> {
            private val serializer: KSerializer<List<Entitlement>> = serializer<List<Entitlement>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListSubjectEntitlementsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListSubjectEntitlementsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Override an entitlement
     * Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.  This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementIdOrFeatureKey The id of the entitlement or the key of the feature.
     * @param entitlementCreateInputs The entitlement to create.
     * @return Entitlement
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun overrideEntitlement(subjectIdOrKey: kotlin.String, entitlementIdOrFeatureKey: kotlin.String, entitlementCreateInputs: EntitlementCreateInputs): HttpResponse<Entitlement> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = entitlementCreateInputs

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementIdOrFeatureKey" + "}", "$entitlementIdOrFeatureKey"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Reset an entitlement
     * Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.  Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed. 
     * @param subjectIdOrKey A unique identifier for a subject.
     * @param entitlementId A unique ULID for an entitlement.
     * @param resetEntitlementUsageRequest 
     * @return void
     */
    open suspend fun resetEntitlementUsage(subjectIdOrKey: kotlin.String, entitlementId: kotlin.String, resetEntitlementUsageRequest: ResetEntitlementUsageRequest): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = resetEntitlementUsageRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset".replace("{" + "subjectIdOrKey" + "}", "$subjectIdOrKey").replace("{" + "entitlementId" + "}", "$entitlementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Void a grant
     * Voiding a grant means it is no longer valid, it doesn&#39;t take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.  For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected. 
     * @param grantId A unique identifier for a grant.
     * @return void
     */
    open suspend fun voidGrant(grantId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("CloudCookieAuth", "CloudTokenAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/grants/{grantId}".replace("{" + "grantId" + "}", "$grantId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
